unit TestSQLiteTable3;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit 
  being tested.

}

interface

uses
  TestFramework, Windows, SQLite3, Classes, SysUtils, SQLiteTable3, Generics.Collections;

type
  // Test methods for class TSQLiteDatabase

  TestTSQLiteDatabase = class(TTestCase)
  strict private
    FSQLiteDatabase: TSQLiteDatabase;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestAddNewSupportedColumnType;
    procedure TestGetTable;
    procedure TestExecSQL;
    procedure TestPrepareSQL;
    procedure TestGetTableValue;
    procedure TestGetTableString;
    procedure TestGetTableStrings;
    procedure TestGetPreparedStatement;
    procedure TestGetPreparedStatement1;
    procedure TestUpdateBlob;
    procedure TestCommit;
    procedure TestRollback;
    procedure TestTableExists;
    procedure TestBackup;
    procedure TestAddCustomCollate;
    procedure TestAddSystemCollate;
    procedure TestParamsClear;
  end;
  // Test methods for class TSQLiteTable

  TestTSQLiteTable = class(TTestCase)
  strict private
    FSQLiteDatabase: TSQLiteDatabase;
    FSQLiteTable: TSQLiteTable;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestFieldAsInteger;
    procedure TestFieldAsBlob;
    procedure TestFieldAsBlobText;
    procedure TestFieldIsNull;
    procedure TestFieldAsString;
    procedure TestFieldAsDouble;
    procedure TestNext;
    procedure TestPrevious;
    procedure TestMoveFirst;
    procedure TestMoveLast;
    procedure TestMoveTo;
  end;
  // Test methods for class TSQLitePreparedStatement

  TestTSQLitePreparedStatement = class(TTestCase)
  strict private
    FSQLiteDatabase: TSQLiteDatabase;
    FSQLitePreparedStatement: TSQLitePreparedStatement;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestClearParams;
    procedure TestSetParams;
    procedure TestSetParamNull;
    procedure TestExecSQLAndMapData;
    procedure TestExecQuery;
    procedure TestExecQuery1;
    procedure TestExecQuery2;
    procedure TestExecSQL;
    procedure TestExecSQL1;
    procedure TestExecSQL2;
    procedure TestExecSQL3;
    procedure TestExecSQL4;
    procedure TestPrepareStatement;
    procedure TestPrepareStatement1;
  end;
  // Test methods for class TSQLiteField

  TestTSQLiteField = class(TTestCase)
  strict private
    FSQLiteDatabase: TSQLiteDatabase;
    FSQLiteField: TSQLiteField;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestIsNull;
    procedure TestAsBlob;
    procedure TestAsBlobPtr;
    procedure TestAsBlobText;
    procedure TestAsBlobTextDef;
    procedure TestAsDateTime;
    procedure TestAsDateTimeDef;
    procedure TestAsDouble;
    procedure TestAsDoubleDef;
    procedure TestAsInteger;
    procedure TestAsIntegerDef;
    procedure TestAsString;
    procedure TestAsStringDef;
    procedure TestValue;
    procedure TestValueDef;
  end;
  // Test methods for class TSQLiteUniTable

  TestTSQLiteUniTable = class(TTestCase)
  strict private
    FSQLiteDatabase: TSQLiteDatabase;
    FSQLiteUniTable: TSQLiteUniTable;
    stmt: TSQLitePreparedStatement;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestFindField;
    procedure TestFieldAsInteger;
    procedure TestFieldAsBlob;
    procedure TestFieldAsBlobPtr;
    procedure TestFieldAsBlobText;
    procedure TestFieldIsNull;
    procedure TestFieldAsString;
    procedure TestFieldAsDouble;
    procedure TestNext;
  end;

implementation

procedure TestTSQLiteDatabase.SetUp;
begin
  FSQLiteDatabase := TSQLiteDatabase.Create('test.db');
end;

procedure TestTSQLiteDatabase.TearDown;
begin
  FSQLiteDatabase.Free;
  FSQLiteDatabase := nil;
end;

procedure TestTSQLiteDatabase.TestAddNewSupportedColumnType;
var
  ColType, iRes: Integer;
  ColTypeName: string;
begin
  ColTypeName := 'BIT';  //uppercase
  ColType := dtInt;
  // TODO: Setup method call parameters
  FSQLiteDatabase.AddNewSupportedColumnType(ColTypeName, ColType);
  // TODO: Validate method results
  Check(TSQLiteDatabase.FColumnTypes.TryGetValue(ColTypeName, iRes));
end;

procedure TestTSQLiteDatabase.TestGetTable;
var
  ReturnValue: TSQLiteTable;
  SQL: string;
begin
  SQL := 'select * from testtable';
  // TODO: Setup method call parameters
  ReturnValue := FSQLiteDatabase.GetTable(SQL);
  try
    Check((ReturnValue.ColCount > 0) and (ReturnValue.RowCount > 0));
  finally
    ReturnValue.Free;
  end;
  // TODO: Validate method results
end;

procedure TestTSQLiteDatabase.TestExecSQL;
var
  SQL: string;
begin
  // TODO: Setup method call parameters
  SQL := 'update testtable set OtherId = 100 where ID = 10';
  FSQLiteDatabase.ExecSQL(SQL);
  // TODO: Validate method results
  Check(FSQLiteDatabase.GetLastChangedRows = 1);
end;

procedure TestTSQLiteDatabase.TestPrepareSQL;
var
  ReturnValue: TSQLiteQuery;
  SQL: string;
begin
  // TODO: Setup method call parameters
  FSQLiteDatabase.ParamsClear;
  SQL := 'update testtable set OtherId = ? where ID = ?';
  ReturnValue := FSQLiteDatabase.PrepareSQL(SQL);
  FSQLiteDatabase.BindSQL(ReturnValue, 1, 101);
  FSQLiteDatabase.BindSQL(ReturnValue, 2, 10);
  FSQLiteDatabase.ExecSQL(ReturnValue);
  // TODO: Validate method results
  Check(FSQLiteDatabase.GetLastChangedRows = 1);
end;

procedure TestTSQLiteDatabase.TestGetTableValue;
var
  ReturnValue: Int64;
  SQL: string;
begin
  // TODO: Setup method call parameters
  SQL := 'select ID from testtable limit 1';
  ReturnValue := FSQLiteDatabase.GetTableValue(SQL);

  Check(ReturnValue = 1);
  // TODO: Validate method results
end;

procedure TestTSQLiteDatabase.TestGetTableString;
var
  ReturnValue: string;
  SQL: string;
begin
  // TODO: Setup method call parameters
  sql := 'select Name from testtable where ID = 2';
  ReturnValue := FSQLiteDatabase.GetTableString(SQL);
  // TODO: Validate method results
  Check(ReturnValue = 'Some Name Русский 1');
end;

procedure TestTSQLiteDatabase.TestGetTableStrings;
var
  Value: TStrings;
  SQL: string;
begin
  // TODO: Setup method call parameters
  SQL := 'select name from testtable limit 1,10';
  Value := TStringList.Create;
  try
    FSQLiteDatabase.GetTableStrings(SQL, Value);
    Check(Value.Count > 0);
  finally
    Value.Free;
  end;
  // TODO: Validate method results
end;

procedure TestTSQLiteDatabase.TestGetPreparedStatement;
var
  ReturnValue: TSQLitePreparedStatement;
  SQL: string;
begin
  // TODO: Setup method call parameters
  SQL := 'select * from testtable where ID > ? and Number > ?';
  ReturnValue := FSQLiteDatabase.GetPreparedStatement(SQL);
  // TODO: Validate method results
  try
    Check(ReturnValue.Stmt <> nil);
  finally
    ReturnValue.Free;
  end;
end;

procedure TestTSQLiteDatabase.TestGetPreparedStatement1;
var
  ReturnValue: TSQLitePreparedStatement;
  SQL: string;
begin
  // TODO: Setup method call parameters
  SQL := 'select * from testtable where ID > ? and Number > ?';
  ReturnValue := FSQLiteDatabase.GetPreparedStatement(SQL, [5, 1.1]);
  // TODO: Validate method results
  try
    Check(ReturnValue.Stmt <> nil);
  finally
    ReturnValue.Free;
  end;
end;

procedure TestTSQLiteDatabase.TestUpdateBlob;
var
  BlobData: TFileStream;
  SQL: string;
begin
  // TODO: Setup method call parameters
  SQL := 'update testtable set picture = ? where ID = 5';
  BlobData := TFileStream.Create(IncludeTrailingPathDelimiter(ExtractFileDir(ParamStr(0))) + 'Sunset.jpg',
   fmOpenRead or fmShareDenyNone);
  try
    FSQLiteDatabase.UpdateBlob(SQL, BlobData);

    Check(FSQLiteDatabase.GetLastChangedRows = 1);
  finally
    BlobData.Free;
  end;
  // TODO: Validate method results

end;

procedure TestTSQLiteDatabase.TestCommit;
var
  iVal, iTest: Int64;
begin
  Randomize;
  iTest := Random(10000000);
  FSQLiteDatabase.BeginTransaction;

  FSQLiteDatabase.ExecSQL(Format('update testtable set OtherID = %D where ID = 10', [iTest]));

  FSQLiteDatabase.Commit;

  iVal := FSQLiteDatabase.GetTableValue('select OtherID from testtable where ID = 10');
  // TODO: Validate method results
  Check(iVal = iTest);
end;

procedure TestTSQLiteDatabase.TestRollback;
var
  iVal, iTest: Int64;
begin
  Randomize;
  iTest := Random(10000000);
  FSQLiteDatabase.BeginTransaction;

  FSQLiteDatabase.ExecSQL(Format('update testtable set OtherID = %D where ID = 10', [iTest]));

  FSQLiteDatabase.Rollback;
  iVal := FSQLiteDatabase.GetTableValue('select OtherID from testtable where ID = 10');
  // TODO: Validate method results
  Check(iVal <> iTest);
end;

procedure TestTSQLiteDatabase.TestTableExists;
var
  ReturnValue: Boolean;
  TableName: string;
begin
  TableName := 'testtable';
  // TODO: Setup method call parameters
  ReturnValue := FSQLiteDatabase.TableExists(TableName);
  // TODO: Validate method results
  Check(ReturnValue);
  TableName := 'notexisting';
  ReturnValue := FSQLiteDatabase.TableExists(TableName);
  CheckFalse(ReturnValue);
end;

procedure TestTSQLiteDatabase.TestBackup;
var
  ReturnValue: Integer;
  TargetDB: TSQLiteDatabase;
begin
  TargetDB := TSQLiteDatabase.Create(IncludeTrailingPathDelimiter(ExtractFileDir(ParamStr(0))) + 'backup.db');
  try
  // TODO: Setup method call parameters
    ReturnValue := FSQLiteDatabase.Backup(TargetDB);

    Check(ReturnValue = SQLITE_DONE);

    DeleteFile(TargetDB.Filename);
  finally
    TargetDB.Free;
  end;
  // TODO: Validate method results
end;

procedure TestTSQLiteDatabase.TestAddCustomCollate;
var
  xCompare: TCollateXCompare;
  name: string;
begin
  // TODO: Setup method call parameters
 // FSQLiteDatabase.AddCustomCollate(name, xCompare);
  Check(True);
  // TODO: Validate method results
end;

procedure TestTSQLiteDatabase.TestAddSystemCollate;
begin
 // FSQLiteDatabase.AddSystemCollate;
  Check(True);
  // TODO: Validate method results
end;

procedure TestTSQLiteDatabase.TestParamsClear;
begin
  FSQLiteDatabase.ParamsClear;
  // TODO: Validate method results
  Check(True);
end;

procedure TestTSQLiteTable.SetUp;
begin
  FSQLiteDatabase := TSQLiteDatabase.Create('test.db');
  FSQLiteTable := TSQLiteTable.Create(FSQLiteDatabase, 'select * from testtable where ID = 1');
end;

procedure TestTSQLiteTable.TearDown;
begin
  FSQLiteDatabase.Free;
  FSQLiteTable.Free;
  FSQLiteTable := nil;
end;

procedure TestTSQLiteTable.TestFieldAsInteger;
var
  ReturnValue: Int64;
  I: Cardinal;
begin
  // TODO: Setup method call parameters
  I := 0;
  ReturnValue := FSQLiteTable.FieldAsInteger(I);
  // TODO: Validate method results
  Check(ReturnValue = 1);
end;

procedure TestTSQLiteTable.TestFieldAsBlob;
var
  ReturnValue: TMemoryStream;
  I: Cardinal;
begin
  // TODO: Setup method call parameters
  I := 5;
//  ReturnValue := TMemoryStream.Create;
  ReturnValue := FSQLiteTable.FieldAsBlob(I);
  // TODO: Validate method results
  try
    Check(ReturnValue.Size > 0);


  finally
    //ReturnValue.Free;
  end;
end;

procedure TestTSQLiteTable.TestFieldAsBlobText;
var
  ReturnValue: string;
  I: Cardinal;
begin
  // TODO: Setup method call parameters
  I := 4;
  ReturnValue := FSQLiteTable.FieldAsBlobText(I);
  // TODO: Validate method results
  Check(ReturnValue <> '');
end;

procedure TestTSQLiteTable.TestFieldIsNull;
var
  ReturnValue: Boolean;
  I: Cardinal;
begin
  // TODO: Setup method call parameters
  I := 3;
  ReturnValue := FSQLiteTable.FieldIsNull(I);
  // TODO: Validate method results
  Check(ReturnValue);
end;

procedure TestTSQLiteTable.TestFieldAsString;
var
  ReturnValue: string;
  I: Cardinal;
begin
  // TODO: Setup method call parameters
  I := 2;
  ReturnValue := FSQLiteTable.FieldAsString(I);
  // TODO: Validate method results
  Check(ReturnValue <> '');
end;

procedure TestTSQLiteTable.TestFieldAsDouble;
var
  ReturnValue: Double;
  I: Cardinal;
begin
  // TODO: Setup method call parameters
  I := 1;
  ReturnValue := FSQLiteTable.FieldAsDouble(I);
  // TODO: Validate method results
  Check(ReturnValue = 4);
end;

procedure TestTSQLiteTable.TestNext;
var
  ReturnValue: Boolean;
begin
  ReturnValue := FSQLiteTable.Next;
  // TODO: Validate method results
  Check(FSQLiteTable.EOF);
end;

procedure TestTSQLiteTable.TestPrevious;
var
  ReturnValue: Boolean;
begin
  ReturnValue := FSQLiteTable.Previous;
  // TODO: Validate method results
  CheckFalse(ReturnValue);
end;

procedure TestTSQLiteTable.TestMoveFirst;
var
  ReturnValue: Boolean;
begin
  ReturnValue := FSQLiteTable.MoveFirst;
  // TODO: Validate method results
  Check(ReturnValue);
end;

procedure TestTSQLiteTable.TestMoveLast;
var
  ReturnValue: Boolean;
begin
  ReturnValue := FSQLiteTable.MoveLast;
  // TODO: Validate method results
  Check(ReturnValue);
end;

procedure TestTSQLiteTable.TestMoveTo;
var
  ReturnValue: Boolean;
  position: Cardinal;
begin
  // TODO: Setup method call parameters
  position := 2;
  ReturnValue := FSQLiteTable.MoveTo(position);
  // TODO: Validate method results
  CheckFalse(ReturnValue);
  position := 0;
  ReturnValue := FSQLiteTable.MoveTo(position);
  Check(ReturnValue);
end;

procedure TestTSQLitePreparedStatement.SetUp;
begin
  FSQLiteDatabase := TSQLiteDatabase.Create('test.db');
 // FSQLitePreparedStatement := TSQLitePreparedStatement.Create(FSQLiteDatabase,
 //   'select * from testtable where (OtherID = ?) and (Name = ?)  and (Number = ?)');
  FSQLitePreparedStatement := TSQLitePreparedStatement.Create(FSQLiteDatabase,
    'select * from testtable where (OtherID = ?) and (Name = ?)  and (Number = ?)', [1, 'Name 1', 1]);
end;

procedure TestTSQLitePreparedStatement.TearDown;
begin
  FSQLiteDatabase.Free;
  FSQLitePreparedStatement.Free;
  FSQLitePreparedStatement := nil;
end;

procedure TestTSQLitePreparedStatement.TestClearParams;
begin
  FSQLitePreparedStatement.ClearParams;
  // TODO: Validate method results
  CheckFalse(FSQLitePreparedStatement.ParamsBound);
end;

procedure TestTSQLitePreparedStatement.TestSetParams;
var
  value: Int64;
  aname: string;
  numb: Double;
begin
  // TODO: Setup method call parameters
  value := 1;
  aname := 'Name 1';
  numb := 1;
  FSQLitePreparedStatement.ClearParams;
  FSQLitePreparedStatement.SetParamInt(1, value);
  FSQLitePreparedStatement.SetParamText(2, aname);
  FSQLitePreparedStatement.SetParamFloat(3, numb);

  Check(FSQLitePreparedStatement.ParamCount = 3);
  // TODO: Validate method results
end;

procedure TestTSQLitePreparedStatement.TestSetParamNull;
var
  name: string;
begin
  // TODO: Setup method call parameters
 // FSQLitePreparedStatement.SetParamNull(name);
 // Check(True);
  // TODO: Validate method results
end;

type
  TMyData = class
  private
    FID: Integer;
    FOtherID: Integer;
    FName: string;
    FNumber: Double;
    FEmpty: Integer;

  public
    property ID: Integer read FID write FID;
    property OtherID: Integer read FOtherID write FOtherID;
    property Name: string read FName write FName;
    property Number: Double read FNumber write FNumber;
    property Empty: Integer read FEmpty write FEmpty;
  end;

procedure TestTSQLitePreparedStatement.TestExecSQLAndMapData;
var
  ReturnValue: Boolean;
  DataList: TObjectList<TMyData>;
begin
  // TODO: Setup method call parameters
  DataList := TObjectList<TMyData>.Create;
  try
    ReturnValue := FSQLitePreparedStatement.ExecSQLAndMapData<TMyData>(DataList);

    Check(ReturnValue);
    Check(DataList.Count > 0);
  finally
    DataList.Free;
  end;
  // TODO: Validate method results
end;

procedure TestTSQLitePreparedStatement.TestExecQuery;
var
  ReturnValue: TSQLiteUniTable;
begin
  ReturnValue := FSQLitePreparedStatement.ExecQuery;

  // TODO: Validate method results
  try
    CheckFalse(ReturnValue.EOF);
  finally
    ReturnValue.Free;
  end;
end;

procedure TestTSQLitePreparedStatement.TestExecQuery1;
var
  ReturnValue: TSQLiteUniTable;
  SQL: string;
begin
  SQL := 'select * from testtable';
  // TODO: Setup method call parameters
  ReturnValue := FSQLitePreparedStatement.ExecQuery(SQL);
  try
    CheckFalse(ReturnValue.EOF);
  finally
    ReturnValue.Free;
  end;
  // TODO: Validate method results
end;

procedure TestTSQLitePreparedStatement.TestExecQuery2;
var
  ReturnValue: TSQLiteUniTable;
  SQL: string;
begin
  // TODO: Setup method call parameters
  SQL := 'select * from testtable where ID = ?';
  FSQLitePreparedStatement.ClearParams;
  FSQLitePreparedStatement.PrepareStatement(SQL);
  ReturnValue := FSQLitePreparedStatement.ExecQuery(SQL, [10]);
  // TODO: Validate method results
  try
    Check(ReturnValue.Fields[0].AsInteger = 10);
  finally
    ReturnValue.Free;
  end;
end;

procedure TestTSQLitePreparedStatement.TestExecSQL;
var
  ReturnValue: Boolean;
begin
//  ReturnValue := FSQLitePreparedStatement.ExecSQL;
  // TODO: Validate method results
end;

procedure TestTSQLitePreparedStatement.TestExecSQL1;
var
  ReturnValue: Boolean;
  SQL: string;
begin
  // TODO: Setup method call parameters
//  ReturnValue := FSQLitePreparedStatement.ExecSQL(SQL);
  // TODO: Validate method results
end;

procedure TestTSQLitePreparedStatement.TestExecSQL2;
var
  ReturnValue: Boolean;
  RowsAffected: Integer;
begin
  // TODO: Setup method call parameters
//  ReturnValue := FSQLitePreparedStatement.ExecSQL(RowsAffected);
  // TODO: Validate method results
end;

procedure TestTSQLitePreparedStatement.TestExecSQL3;
var
  ReturnValue: Boolean;
  RowsAffected: Integer;
  SQL: string;
begin
  // TODO: Setup method call parameters
 // ReturnValue := FSQLitePreparedStatement.ExecSQL(SQL, RowsAffected);
  // TODO: Validate method results
end;

procedure TestTSQLitePreparedStatement.TestExecSQL4;
var
  ReturnValue: Boolean;
  SQL: string;
begin
  // TODO: Setup method call parameters
 // ReturnValue := FSQLitePreparedStatement.ExecSQL(SQL, []);
  // TODO: Validate method results
end;

procedure TestTSQLitePreparedStatement.TestPrepareStatement;
var
  SQL: string;
begin
  // TODO: Setup method call parameters
//  FSQLitePreparedStatement.PrepareStatement(SQL);
  // TODO: Validate method results
end;

procedure TestTSQLitePreparedStatement.TestPrepareStatement1;
var
  SQL: string;
begin
  // TODO: Setup method call parameters
//  FSQLitePreparedStatement.PrepareStatement(SQL, []);
  // TODO: Validate method results
end;

procedure TestTSQLiteField.SetUp;
begin
  FSQLiteField := TSQLiteField.Create;
end;

procedure TestTSQLiteField.TearDown;
begin
  FSQLiteField.Free;
  FSQLiteField := nil;
end;

procedure TestTSQLiteField.TestIsNull;
var
  ReturnValue: Boolean;
begin
//  ReturnValue := FSQLiteField.IsNull;
  // TODO: Validate method results
end;

procedure TestTSQLiteField.TestAsBlob;
var
  ReturnValue: TMemoryStream;
begin
//  ReturnValue := FSQLiteField.AsBlob;
  // TODO: Validate method results
end;

procedure TestTSQLiteField.TestAsBlobPtr;
var
  ReturnValue: Pointer;
  iNumBytes: Integer;
begin
  // TODO: Setup method call parameters
 // ReturnValue := FSQLiteField.AsBlobPtr(iNumBytes);
  // TODO: Validate method results
end;

procedure TestTSQLiteField.TestAsBlobText;
var
  ReturnValue: string;
begin
//  ReturnValue := FSQLiteField.AsBlobText;
  // TODO: Validate method results
end;

procedure TestTSQLiteField.TestAsBlobTextDef;
var
  ReturnValue: string;
  Def: string;
begin
  // TODO: Setup method call parameters
 // ReturnValue := FSQLiteField.AsBlobTextDef(Def);
  // TODO: Validate method results
end;

procedure TestTSQLiteField.TestAsDateTime;
var
  ReturnValue: TDateTime;
begin
 // ReturnValue := FSQLiteField.AsDateTime;
  // TODO: Validate method results
end;

procedure TestTSQLiteField.TestAsDateTimeDef;
var
  ReturnValue: TDateTime;
  Def: TDateTime;
begin
  // TODO: Setup method call parameters
 // ReturnValue := FSQLiteField.AsDateTimeDef(Def);
  // TODO: Validate method results
end;

procedure TestTSQLiteField.TestAsDouble;
var
  ReturnValue: Double;
begin
 // ReturnValue := FSQLiteField.AsDouble;
  // TODO: Validate method results
end;

procedure TestTSQLiteField.TestAsDoubleDef;
var
  ReturnValue: Double;
  Def: Double;
begin
  // TODO: Setup method call parameters
 // ReturnValue := FSQLiteField.AsDoubleDef(Def);
  // TODO: Validate method results
end;

procedure TestTSQLiteField.TestAsInteger;
var
  ReturnValue: Int64;
begin
 // ReturnValue := FSQLiteField.AsInteger;
  // TODO: Validate method results
end;

procedure TestTSQLiteField.TestAsIntegerDef;
var
  ReturnValue: Int64;
  Def: Int64;
begin
  // TODO: Setup method call parameters
 // ReturnValue := FSQLiteField.AsIntegerDef(Def);
  // TODO: Validate method results
end;

procedure TestTSQLiteField.TestAsString;
var
  ReturnValue: string;
begin
 // ReturnValue := FSQLiteField.AsString;
  // TODO: Validate method results
end;

procedure TestTSQLiteField.TestAsStringDef;
var
  ReturnValue: string;
  Def: string;
begin
  // TODO: Setup method call parameters
 // ReturnValue := FSQLiteField.AsStringDef(Def);
  // TODO: Validate method results
end;

procedure TestTSQLiteField.TestValue;
var
  ReturnValue: Variant;
begin
//  ReturnValue := FSQLiteField.Value;
  // TODO: Validate method results
end;

procedure TestTSQLiteField.TestValueDef;
var
  ReturnValue: Variant;
  Def: Variant;
begin
  // TODO: Setup method call parameters
 // ReturnValue := FSQLiteField.ValueDef(Def);
  // TODO: Validate method results
end;

procedure TestTSQLiteUniTable.SetUp;
begin
  FSQLiteDatabase := TSQLiteDatabase.Create('test.db');
  stmt := TSQLitePreparedStatement.Create(FSQLiteDatabase);
  FSQLiteUniTable := stmt.ExecQuery('select * from testtable');
end;

procedure TestTSQLiteUniTable.TearDown;
begin
  FSQLiteUniTable.Free;
  stmt.Free;
  FSQLiteDatabase.Free;
  FSQLiteUniTable := nil;
end;

procedure TestTSQLiteUniTable.TestFindField;
var
  ReturnValue: TSQLiteField;
  AFieldName: string;
begin
  // TODO: Setup method call parameters
  AFieldName := 'Number';
  ReturnValue := FSQLiteUniTable.FindField(AFieldName);
  // TODO: Validate method results
  Check(ReturnValue <> nil);
end;

procedure TestTSQLiteUniTable.TestFieldAsInteger;
var
  ReturnValue: Int64;
  I: Cardinal;
begin
  // TODO: Setup method call parameters
  ReturnValue := FSQLiteUniTable.FieldAsInteger(0);
  // TODO: Validate method results
  Check(ReturnValue > 0);
end;

procedure TestTSQLiteUniTable.TestFieldAsBlob;
var
  ReturnValue: TMemoryStream;
  I: Cardinal;
begin
  // TODO: Setup method call parameters
 // ReturnValue := FSQLiteUniTable.FieldAsBlob(I);
  // TODO: Validate method results
end;

procedure TestTSQLiteUniTable.TestFieldAsBlobPtr;
var
  ReturnValue: Pointer;
  iNumBytes: Integer;
  I: Cardinal;
begin
  // TODO: Setup method call parameters
//  ReturnValue := FSQLiteUniTable.FieldAsBlobPtr(I, iNumBytes);
  // TODO: Validate method results
end;

procedure TestTSQLiteUniTable.TestFieldAsBlobText;
var
  ReturnValue: string;
  I: Cardinal;
begin
  // TODO: Setup method call parameters
//  ReturnValue := FSQLiteUniTable.FieldAsBlobText(I);
  // TODO: Validate method results
end;

procedure TestTSQLiteUniTable.TestFieldIsNull;
var
  ReturnValue: Boolean;
  I: Cardinal;
begin
  // TODO: Setup method call parameters
  ReturnValue := FSQLiteUniTable.FieldIsNull(3);
  // TODO: Validate method results
  Check(ReturnValue);
end;

procedure TestTSQLiteUniTable.TestFieldAsString;
var
  ReturnValue: string;
  I: Cardinal;
begin
  // TODO: Setup method call parameters
//  ReturnValue := FSQLiteUniTable.FieldAsString(I);
  // TODO: Validate method results
end;

procedure TestTSQLiteUniTable.TestFieldAsDouble;
var
  ReturnValue: Double;
  I: Cardinal;
begin
  // TODO: Setup method call parameters
//  ReturnValue := FSQLiteUniTable.FieldAsDouble(I);
  // TODO: Validate method results
end;

procedure TestTSQLiteUniTable.TestNext;
var
  ReturnValue: Boolean;
begin
  ReturnValue := FSQLiteUniTable.Next;
  // TODO: Validate method results
  Check(ReturnValue);
end;

initialization
  // Register any test cases with the test runner
  RegisterTest(TestTSQLiteDatabase.Suite);
  RegisterTest(TestTSQLiteTable.Suite);
  RegisterTest(TestTSQLitePreparedStatement.Suite);
  RegisterTest(TestTSQLiteField.Suite);
  RegisterTest(TestTSQLiteUniTable.Suite);
end.

